import numpy as np
# Standard library
from pathlib import Path

# Third-party libraries
import mujoco
import numpy as np
from mujoco import viewer
from rich.console import Console

from src.ariel.body_phenotypes.robogen_lite.cppn_neat.genome import Genome

import networkx as nx
import numpy as np



# Local libraries
from ariel.body_phenotypes.robogen_lite.config import (
    NUM_OF_FACES,
    NUM_OF_ROTATIONS,
    NUM_OF_TYPES_OF_MODULES,
)
from ariel.body_phenotypes.robogen_lite.decoders.hi_prob_decoding import (
    HighProbabilityDecoder,
)

from ariel.body_phenotypes.robogen_lite.constructor import (
    construct_mjspec_from_graph,
)

from ariel.body_phenotypes.robogen_lite.modules.core import CoreModule
from ariel.simulation.environments import SimpleFlatWorld
from ariel.utils.renderers import single_frame_renderer

# Global constants
SCRIPT_NAME = __file__.split("/")[-1][:-3]
CWD = Path.cwd()
DATA = Path(CWD / "__data__" / SCRIPT_NAME)
DATA.mkdir(exist_ok=True)
SEED = 40

# Global functions
console = Console()
RNG = np.random.default_rng(SEED)


def create_probability_spaces(genome: Genome) -> tuple[np.ndarray, np.ndarray, np.ndarray]:

    T = NUM_OF_TYPES_OF_MODULES
    F = NUM_OF_FACES
    R = NUM_OF_ROTATIONS
    N = 20
    
    # Initialize the three probability spaces
    type_p_space = np.zeros((N, T), dtype=np.float32)
    rot_p_space = np.zeros((N, R), dtype=np.float32)
    conn_p_space = np.zeros((N, N, F), dtype=np.float32)
    
    # --- A. Type and Rotation Matrices ---
    # These are generated by sampling each module's index
    for i in range(N):
        # The simplest spatial input is the normalized index itself:
        input_i_norm = float(i) / N
        
        cppn_inputs = [
            input_i_norm,  # X-coordinate (or Module Index)
            0.0,           # Y-coordinate placeholder
            0.0            # D-coordinate placeholder
        ]
        
        # CPPN should have >= T + R outputs configured
        raw_outputs = genome.activate(cppn_inputs) 
        
        # 1. Type Probabilities (T outputs)
        type_raw = np.array(raw_outputs[:T])
        # Apply Softmax to convert raw scores to a probability distribution
        exp_type = np.exp(type_raw)
        type_p_space[i, :] = exp_type / np.sum(exp_type)

        # 2. Rotation Probabilities (R outputs)
        rot_raw = np.array(raw_outputs[T:T+R])
        # Apply Softmax 
        exp_rot = np.exp(rot_raw)
        rot_p_space[i, :] = exp_rot / np.sum(exp_rot)


    # --- B. Connection Probability Matrix ---
    # The connection matrix is N x N x F (Parent i -> Child j on Face k)
    # This requires 3 inputs for its coordinates: i, j, k
    
    for i in range(N):      # Parent module index
        for j in range(N):  # Child module index
            for k in range(F):  # Face index
                
                # Normalize inputs to keep them in the CPPN's effective input range (e.g., [-1, 1])
                cppn_inputs = [
                    float(i) / N, 
                    float(j) / N, 
                    float(k) / F
                ]
                
                # The CPPN output only needs 1 value (the connection score)
                raw_output = genome.activate(cppn_inputs)
                
                # The connection matrix typically stores the raw score/weight, 
                # and the decoder handles the selection (argmax/highest probability).
                conn_p_space[i, j, k] = raw_output[0] 

    return type_p_space, conn_p_space, rot_p_space

def decode_robot_morphology(cppn_genome: Genome, decoder: HighProbabilityDecoder) -> nx.DiGraph:
    """Combines CPPN output with the external decoder."""
    
    # 1. Generate probability matrices
    type_p, conn_p, rot_p = create_probability_spaces(cppn_genome)
    
    # 2. Decode the graph using the external decoder
    robot_graph = decoder.probability_matrices_to_graph(
        type_p,
        conn_p,
        rot_p,
    )
    
    # Visualize the graph
    # draw_graph(robot_graph)

    return robot_graph

def run(
    robot: CoreModule,
    *,
    with_viewer: bool = False,
) -> None:
    """Entry point."""
    # MuJoCo configuration
    viz_options = mujoco.MjvOption()  # visualization of various elements

    # Visualization of the corresponding model or decoration element
    viz_options.flags[mujoco.mjtVisFlag.mjVIS_TRANSPARENT] = True
    viz_options.flags[mujoco.mjtVisFlag.mjVIS_ACTUATOR] = True
    viz_options.flags[mujoco.mjtVisFlag.mjVIS_BODYBVH] = True

    # MuJoCo basics
    world = SimpleFlatWorld()

    # Set random colors for geoms
    for i in range(len(robot.spec.geoms)):
        robot.spec.geoms[i].rgba[-1] = 0.5

    # Spawn the robot at the world
    world.spawn(robot.spec)

    # Compile the model
    model = world.spec.compile()
    data = mujoco.MjData(model)

    # Save the model to XML
    xml = world.spec.to_xml()
    with (DATA / f"{SCRIPT_NAME}.xml").open("w", encoding="utf-8") as f:
        f.write(xml)

    # Number of actuators and DoFs
    console.log(f"DoF (model.nv): {model.nv}, Actuators (model.nu): {model.nu}")

    # Reset state and time of simulation
    mujoco.mj_resetData(model, data)

    # Render
    single_frame_renderer(model, data, steps=10)

    # View
    if with_viewer:
        viewer.launch(model=model, data=data)


if __name__ == "__main__":
    # --- 1. Setup Parameters ---
    N = 20  # The number of modules used in create_probability_spaces [cite: 2]
    
    # --- 2. Initialize the Decoder ---
    # The decoder needs to know the total number of modules (N) 
    hpd = HighProbabilityDecoder(num_modules=N) 
    
    # --- 3. Placeholder for Genome Initialization ---
    # In a real run, you would load or generate a CPPN genome here
    # Placeholder: Assuming a genome object 'my_cppn_genome' exists
    # my_cppn_genome = Genome(...) 
    
    # --- 4. Execute Decoding ---
    # decoded_robot = decode_robot_morphology(my_cppn_genome, hpd)
    
    # Since we can't run the full NEAT/CPPN here, here is a functional example
    # that uses random data (similar to the example file) to show the setup:
    
    # --- Example: Create a random Genome for testing ---
    # We need to know the required number of inputs and outputs for the CPPN
    # Max Inputs: 3 (i, j, k for connections)
    # Max Outputs: T + R 
    T = NUM_OF_TYPES_OF_MODULES
    R = NUM_OF_ROTATIONS
    # This requires proper global ID tracking, but for a single test:
    my_cppn_genome = Genome.random(
        num_inputs=3, 
        num_outputs=(T + R), 
        next_node_id=6, 
        next_innov_id=12
    )
    decoded_robot = decode_robot_morphology(my_cppn_genome, hpd)
    
    # Construct the robot from the graph
    core = construct_mjspec_from_graph(decoded_robot)

    run(core, with_viewer=True)



